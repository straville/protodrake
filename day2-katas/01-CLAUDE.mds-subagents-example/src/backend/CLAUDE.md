# Backend — CLAUDE.md

Express 5 API with Drizzle ORM (PostgreSQL) and Redis cache.

## Structure

```
src/backend/
  server.ts              # Express app setup, middleware chain
  routes/                # Route handlers grouped by domain
    users.ts
    billing.ts
    ...
  services/              # Business logic (called by routes, never by other services)
  db/
    schema.ts            # Drizzle schema — single source of truth for DB structure
    pool.ts              # Connection pool config
    queries/             # Reusable query functions (one file per table)
    migrations/          # Generated by drizzle-kit, never hand-edit
    raw/                 # Raw SQL (justified in comments)
  cache/
    client.ts            # ioredis singleton
    store.ts             # Cache read/write helpers
    ttl.ts               # TTL constants
  drivers/               # Third-party service wrappers
  middleware/            # Express middleware (auth, validation, rate-limit)
  config/
    env.ts               # Zod-validated env vars
  errors.ts              # AppError class and error codes
  types/                 # Backend-specific types
```

## Patterns

**Route -> Service -> DB/Cache.** Routes validate input (zod), call a service, return response.
Services contain logic and call DB queries or cache. Services never import Express types.

```ts
// Route
router.post('/users', validate(createUserSchema), async (req, res) => {
  const user = await userService.create(req.body);
  res.status(201).json(user);
});

// Service
export const userService = {
  async create(data: CreateUser) {
    const user = await userQueries.insert(data);
    await cacheStore.invalidate(`users:list`);
    return user;
  }
};
```

**Validation**: Every route uses zod schemas from `routes/{domain}.schemas.ts`.
Schema file sits next to route file.

**Auth middleware** attaches `req.user` (typed via `@types/express` augmentation in `types/express.d.ts`).

## Database Rules

- One query file per table in `db/queries/`. Export named functions, not a class.
- Use `returning()` on inserts/updates to avoid extra SELECT.
- Soft delete via `deletedAt` column — filter in queries, not middleware.
- Use `db.transaction()` for multi-table writes. Pass `tx` through:
  ```ts
  async function transferCredits(fromId: string, toId: string, amount: number) {
    return db.transaction(async (tx) => {
      await deductCredits(tx, fromId, amount);
      await addCredits(tx, toId, amount);
    });
  }
  ```

## Cache Rules

- Read-through pattern: check cache -> miss -> query DB -> populate cache -> return.
- Cache only at the service layer, never in queries or routes.
- Use `store.getOrSet(key, ttl, fetchFn)` helper — don't manually get/set.
- Log cache hit/miss ratio in dev via `CACHE_DEBUG=1` env var.

## Adding a new endpoint

1. Add zod schema in `routes/{domain}.schemas.ts`
2. Add route handler in `routes/{domain}.ts`
3. Add service function in `services/{domain}.ts`
4. Add DB query if needed in `db/queries/{table}.ts`
5. Add unit test for service, integration test for route
6. If schema changed: `pnpm db:generate` then `pnpm db:migrate`
